<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>スクラッチくじ（3×3）</title>
  <style>
    :root{
      --accent:#8b5cf6; --muted:#6b7280; --panel:#ffffff; --text:#0b1220;
      --panel-max-width: 880px;
      --outer-padding: clamp(12px, 4vw, 28px);
      --grid-gap: clamp(8px, 2vw, 14px);
      --cell-radius: 12px;
    }
    html, body {
      height:100%; margin:0; font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color:var(--text); background:#ffffff;
      overscroll-behavior-y: none; /* ブラウザ対応でプル抑止を試みる */
      touch-action:none;
    }
    body{display:flex; align-items:center; justify-content:center; padding:var(--outer-padding)}
    .panel{width:min(100%, var(--panel-max-width)); background:var(--panel); border-radius:16px; padding:clamp(12px,3vw,20px); box-shadow:0 12px 40px rgba(2,6,23,0.06); position:relative}
    header{display:flex; align-items:center; gap:12px; flex-wrap:wrap}
    header h1{margin:0;font-size:clamp(18px,2.4vw,22px)}
    .small{font-size:clamp(12px,1.4vw,13px); color:var(--muted)}

    .content{display:grid; grid-template-columns: 1fr minmax(240px, 0.9fr); align-items:start; gap:clamp(12px,3vw,20px); margin-top:clamp(10px,2vw,16px)}
    .grid-wrapper{display:flex; justify-content:center}
    .grid{display:grid; grid-template-columns:repeat(3,1fr); gap:var(--grid-gap); width:min(92vw,560px)}
    .cell{position:relative; border-radius:var(--cell-radius); overflow:hidden; background:#f8fafc; box-shadow:0 6px 18px rgba(11,18,32,0.03); cursor:pointer}
    .cell-inner{position:relative; aspect-ratio:1/1}
    .art{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-weight:800; letter-spacing:0.6px; font-size:clamp(14px,2vw,18px); overflow:hidden}
    .img-1{background:linear-gradient(180deg,#ffe4d6,#ffd7be)}
    .img-2{background:linear-gradient(180deg,#fff3bf,#ffe8a8)}
    .img-3{background:linear-gradient(180deg,#d8f5e8,#b7f0d6)}
    .img-4{background:linear-gradient(180deg,#cfe4ff,#9fd2ff)}
    .img-5{background:linear-gradient(180deg,#f3f4f6,#e6eef8)}
    canvas.scratch{position:absolute; inset:0; display:block; touch-action:none}

    .meta{min-width:0}
    .legend{display:flex; gap:8px; flex-wrap:wrap}
    .legend .item{display:flex; gap:8px; align-items:center; padding:6px 8px; border-radius:8px; background:rgba(11,18,32,0.02)}
    .swatch{width:28px;height:28px;border-radius:6px; overflow:hidden; display:flex; align-items:center; justify-content:center}
    .result{margin-top:14px; padding:12px; border-radius:10px; background:rgba(11,18,32,0.02); min-height:64px}
    .line-highlight{outline:3px solid rgba(139,92,246,0.14); box-shadow:0 8px 24px rgba(139,92,246,0.12)}

    .confetti-overlay{position:absolute; inset:0; pointer-events:none; z-index:40}

    .win-popup{position:absolute; left:50%; top:18%; transform:translateX(-50%); background:linear-gradient(180deg,rgba(255,255,255,0.98),white); padding:16px 20px; border-radius:12px; box-shadow:0 12px 36px rgba(11,18,32,0.12); z-index:50; display:none; text-align:center; width:min(92vw,460px)}
    .win-popup.show{display:block}
    .win-title{font-size:clamp(16px,2.4vw,20px); font-weight:800; color:var(--accent); margin-bottom:6px}
    .win-sub{font-size:clamp(13px,1.8vw,14px); color:var(--text)}

    footer{display:flex; justify-content:space-between; align-items:center; margin-top:14px; gap:12px; flex-wrap:wrap}

    @media(max-width:760px){ .content{grid-template-columns:1fr} .grid{width:min(94vw,520px)} }
  </style>
</head>
<body>
  <div class="panel" id="panel">
    <header>
      <h1>スクラッチくじ（3×3）</h1>
      <div class="small">おにぎりを買っていただいてありがとうございました! 当たっても景品などは存在しません</div>
    </header>

    <div class="content">
      <div class="grid-wrapper">
        <div class="grid" id="grid"></div>
      </div>

      <div class="meta">
        <div class="legend" id="legend"></div>
        <div class="result" id="result">カードが読み込まれます。こすって削ってください。全マス開けると判定します。</div>
        <div style="margin-top:10px" class="small">カードID: <span id="cardId">-</span></div>
      </div>
    </div>

    <div class="confetti-overlay" id="confetti-overlay"></div>

    <div class="win-popup" id="win-popup">
      <div class="win-title" id="win-title">1-1のおにぎりを買っていただいてありがとうございました!</div>
      <div class="win-sub" id="win-sub">当選おめでとうございます!</div>
    </div>

  </div>

  <script>
    // ========== データ ==========
    window.IMAGES = [
      {id:'image1', label:'イタリアンおにぎり', rank:1, path:'assets/image1.png'},
      {id:'image2', label:'青菜おにぎり', rank:2, path:'assets/image2.png'},
      {id:'image3', label:'塩おにぎり', rank:3, path:'assets/image3.png'},
      {id:'image4', label:'くまなんの鼻', rank:4, path:'assets/image4.png'},
      {id:'image5', label:'おにぎり', rank:5, path:'assets/image5.png'} // <-- ここは拡張子に合わせて変更
    ];
    const DEFAULT_PROBS = { image1:0.05, image2:0.10, image3:0.20, image4:0.25, image5:0.40 };
    const LINES = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];

    // 設定
    const SCRATCH_RADIUS = 18;
    const REVEAL_THRESHOLD = 0.80;
    const CONFETTI_COLORS = ['#ff4d6d','#ffd166','#8b5cf6','#34d399','#60a5fa'];
    const CONFETTI_DURATION = 4500;

    // DOM
    const gridEl = document.getElementById('grid');
    const legendEl = document.getElementById('legend');
    const resultEl = document.getElementById('result');
    const cardIdEl = document.getElementById('cardId');
    const confettiOverlay = document.getElementById('confetti-overlay');
    const winPopup = document.getElementById('win-popup');
    const winTitle = document.getElementById('win-title');
    const winSub = document.getElementById('win-sub');

    // 状態
    let currentCard = null;
    let cellCanvases = [];

    // ========== ユーティリティ ==========
    function isAtPageTop(){
      return (window.scrollY || document.documentElement.scrollTop || 0) <= 0;
    }
    function isAtPageBottom(){
      const scrollY = window.scrollY || document.documentElement.scrollTop || 0;
      const docH = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
      const winH = window.innerHeight || document.documentElement.clientHeight;
      return (scrollY + winH) >= (docH - 1);
    }
    function rankOf(imageId){ const im = IMAGES.find(x=>x.id===imageId); return im?im.rank||999:999; }

    // ========== ペイント（覆い） ==========
    function paintCover(canvas){
      const ctx = canvas.getContext('2d');
      const ratio = window.devicePixelRatio || 1;
      ctx.setTransform(ratio,0,0,ratio,0,0);
      const cssW = canvas.width / ratio;
      const cssH = canvas.height / ratio;
      ctx.globalCompositeOperation = 'source-over';
      ctx.clearRect(0,0,cssW,cssH);
      ctx.fillStyle = '#c1c7cc';
      ctx.fillRect(0,0,cssW,cssH);
      ctx.fillStyle = '#374151';
      ctx.font = '700 14px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('こすって削る', cssW/2, cssH/2);
    }

    // ========== レジェンド表示更新 ==========
    function renderLegend(){
      legendEl.innerHTML = '';
      IMAGES.forEach((im, idx) => {
        const it = document.createElement('div'); it.className='item';
        const sw = document.createElement('div'); sw.className='swatch'; sw.style.minWidth='28px'; sw.style.minHeight='28px';
        const lab = document.createElement('div'); lab.innerText = im.label || im.id; lab.className='small';
        it.appendChild(sw); it.appendChild(lab); legendEl.appendChild(it);
        im._legendSwatch = sw;
      });
      updateLegendPreview();
    }

    function updateLegendPreview(){
      IMAGES.forEach((im, idx) => {
        const sw = im._legendSwatch;
        if(!sw) return;
        sw.innerHTML = '';
        sw.className = 'swatch';
        if(im.path){
          const img = document.createElement('img');
          img.src = im.path;
          img.alt = im.id;
          img.style.width = '100%'; img.style.height = '100%'; img.style.objectFit = 'cover'; img.style.display='block';
          img.addEventListener('error', ()=>{
            // 読めなければグラデ背景にフォールバック
            sw.className = 'swatch img-' + (idx+1);
            sw.innerHTML = '';
          });
          img.addEventListener('load', ()=> {
            // 成功したら何もしない（imgが表示される）
            sw.classList.remove(...Array.from(sw.classList).filter(c=>c.startsWith('img-')));
          });
          sw.appendChild(img);
        } else {
          sw.className = 'swatch img-' + (idx+1);
        }
      });
    }

    // ========== グリッド構築 ==========
    function buildGrid(){
      gridEl.innerHTML = '';
      cellCanvases = [];
      for(let i=0;i<9;i++){
        const cell = document.createElement('div'); cell.className='cell'; cell.dataset.index = i;
        const inner = document.createElement('div'); inner.className='cell-inner';
        const art = document.createElement('div'); art.className='art'; art.dataset.img=''; art.classList.add('img-5'); art.innerText='';
        const cvs = document.createElement('canvas'); cvs.className='scratch'; cvs.dataset.index = i; cvs.style.touchAction='none';
        inner.appendChild(art); inner.appendChild(cvs); cell.appendChild(inner); gridEl.appendChild(cell);
        cellCanvases.push({canvas:cvs, art:art, cellEl:cell, inner:inner});

        // ResizeObserver：サイズ変化時に再描画（Androidの初回ちらつき対策）
        const ro = new ResizeObserver(()=>{
          try{ resizeCanvasToElement(cvs, cell); paintCover(cvs); requestAnimationFrame(()=> paintCover(cvs)); }catch(e){}
        });
        ro.observe(inner);
        cvs._ro = ro;
      }
    }

    function resizeCanvasToElement(canvas, container){
      const inner = container.querySelector('.cell-inner');
      const rect = inner.getBoundingClientRect();
      const w = Math.max(1, rect.width); const h = Math.max(1, rect.height);
      const ratio = window.devicePixelRatio || 1;
      canvas.width = Math.round(w * ratio);
      canvas.height = Math.round(h * ratio);
      canvas.style.width = w + 'px'; canvas.style.height = h + 'px';
      const ctx = canvas.getContext('2d'); ctx.setTransform(ratio,0,0,ratio,0,0);
    }

    // ========== カード生成 / レンダリング ==========
    function generateCard(){
      const id = 'CARD-'+Date.now().toString(36).toUpperCase();
      const cells = Array.from({length:9}).map(()=> sampleByProb(DEFAULT_PROBS));
      currentCard = {
  id,
  cells,
  revealed: Array.from({length:9}).map(()=>false),
  // announcedLines は既に演出したラインのインデックス（LINESのindex）を保持
  announcedLines: []  // [] なら未発火
};

      cardIdEl.innerText = id;
      renderCard();
      resultEl.innerHTML = 'カードが表示されました。こすって削ってください。';
    }

    function sampleByProb(probs){ const r=Math.random(); let acc=0; for(const k in probs){ acc+=probs[k]; if(r<=acc) return k;} return Object.keys(probs).pop(); }

    function renderCard(){
      const cells = currentCard.cells;
      cellCanvases.forEach((entry,i)=>{
        const art = entry.art; const cvs = entry.canvas; const cell = entry.cellEl; const inner = entry.inner;
        const imgId = cells[i];
        art.dataset.img = imgId;
        art.className = 'art img-'+(IMAGES.findIndex(x=>x.id===imgId)+1);
        art.innerText = imgId;

        // もし IMAGES.path があるなら <img> を入れて表示（assets/... や data:URL に対応）
        const imgDef = IMAGES.find(x=>x.id===imgId);
        if(imgDef && imgDef.path){
          art.innerHTML = '';
          const img = document.createElement('img');
          img.src = imgDef.path;
          img.alt = imgId;
          img.style.width='100%'; img.style.height='100%'; img.style.objectFit='cover'; img.style.display='block';
          img.addEventListener('error', ()=> {
            art.innerHTML = imgId;
          });
          art.appendChild(img);
        }

        // canvas sizing & cover paint
        resizeCanvasToElement(cvs, cell);
        paintCover(cvs);
        // 二重描画して不安定なブラウザのちらつきを減らす
        requestAnimationFrame(()=> paintCover(cvs));
        // initialize scratch handlers
        initializeScratchCanvas(cvs, i);

        cell.classList.remove('line-highlight');
        showCanvas(cvs);
      });

      // legend をカードに合わせて更新（画像パスが変わった場合など）
      updateLegendPreview();
    }

    // ========== スクラッチ処理（誤削り対策：上端プル／下端バウンス無効化） ==========
    function initializeScratchCanvas(canvas, index){
      const ctx = canvas.getContext('2d');
      const ratio = window.devicePixelRatio || 1;
      ctx.setTransform(ratio,0,0,ratio,0,0);

      // ensure cover is painted (already done in renderCard) but re-apply for safety
      paintCover(canvas);
      requestAnimationFrame(()=> paintCover(canvas));

      const START_SCRATCH_THRESHOLD = 8; // px
      let started = false;
      let downPos = null;
      let cancelledAsScroll = false;
      let last = null;

      function getLocalPosFromEvent(e){
        const rect = canvas.getBoundingClientRect();
        if(e.touches && e.touches.length) return {x:e.touches[0].clientX-rect.left, y:e.touches[0].clientY-rect.top, pageY:e.touches[0].pageY};
        return {x:e.clientX-rect.left, y:e.clientY-rect.top, pageY:e.pageY};
      }

      function scratchAt(x,y,r){
        ctx.globalCompositeOperation = 'destination-out';
        ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.closePath();
        ctx.globalCompositeOperation = 'source-over';
      }

      const onMove = (e)=>{
        if(!downPos || cancelledAsScroll) return;
        e.preventDefault();
        const p = getLocalPosFromEvent(e);
        const dx = p.x - downPos.x;
        const dy = p.y - downPos.y;
        const dist = Math.hypot(dx,dy);

        if(!started){
          const verticalDominant = Math.abs(dy) > Math.abs(dx);
          if(verticalDominant){
            if(dy > START_SCRATCH_THRESHOLD && isAtPageTop()){
              cancelledAsScroll = true; return;
            }
            if(dy < -START_SCRATCH_THRESHOLD && isAtPageBottom()){
              cancelledAsScroll = true; return;
            }
          }
          if(dist >= START_SCRATCH_THRESHOLD){
            started = true;
            last = p;
            scratchAt(last.x, last.y, SCRATCH_RADIUS);
          } else {
            return;
          }
        } else {
          const dx2 = p.x - last.x, dy2 = p.y - last.y;
          const dist2 = Math.hypot(dx2,dy2);
          const steps = Math.max(Math.ceil(dist2 / (SCRATCH_RADIUS/2)), 1);
          for(let s=0;s<steps;s++){
            const t = s/steps;
            scratchAt(last.x + dx2*t, last.y + dy2*t, SCRATCH_RADIUS);
          }
          last = p;
        }

        if(Math.random() < 0.12) checkRevealPercent(index);
      };

      const endCommon = ()=>{
        canvas.removeEventListener('pointermove', onMove);
        canvas.removeEventListener('touchmove', onMove);
        window.removeEventListener('pointerup', onUp);
        window.removeEventListener('touchend', onUp);
        window.removeEventListener('pointercancel', onCancel);
        window.removeEventListener('touchcancel', onCancel);
        if(!cancelledAsScroll) checkRevealPercent(index);
        started = false; cancelledAsScroll = false; downPos = null; last = null;
      };

      const onUp = ()=> endCommon();
      const onCancel = ()=> endCommon();

      const onDown = (e)=>{
        e.preventDefault();
        cancelledAsScroll = false; started = false;
        downPos = getLocalPosFromEvent(e);
        canvas.addEventListener('pointermove', onMove, {passive:false});
        canvas.addEventListener('touchmove', onMove, {passive:false});
        window.addEventListener('pointerup', onUp, {passive:false});
        window.addEventListener('touchend', onUp, {passive:false});
        window.addEventListener('pointercancel', onCancel, {passive:false});
        window.addEventListener('touchcancel', onCancel, {passive:false});
      };

      // cleanup old handlers if any
      if(canvas._onDown){ return ;canvas.removeEventListener('pointerdown', canvas._onDown); canvas.removeEventListener('touchstart', canvas._onDown); }
      canvas._onDown = onDown;
      canvas.addEventListener('pointerdown', onDown, {passive:false});
      canvas.addEventListener('touchstart', onDown, {passive:false});
    }

    function checkRevealPercent(index){
  const entry = cellCanvases[index];
  const canvas = entry.canvas;
  const ctx = canvas.getContext('2d');
  try{
    const w = canvas.width; const h = canvas.height;
    const imageData = ctx.getImageData(0,0,w,h).data;
    let trans=0, total=0; const step = 4 * 6;
    for(let i=3;i<imageData.length;i+=step){ if(imageData[i]===0) trans++; total++; }
    const cleared = trans/Math.max(total,1);
    if(cleared >= REVEAL_THRESHOLD){
      if(!currentCard.revealed[index]){
        // このセルが「新たに露出」した瞬間
        currentCard.revealed[index] = true;
        hideCanvas(canvas);

        // このセルを含むラインだけをチェックする
        const containingLines = LINES.map((l, idx)=> ({line:l, idx})).filter(obj => obj.line.includes(index));
        // そのうち、まだ発火していないラインが揃っているか確認
        for(const obj of containingLines){
          const line = obj.line;
          const lineIdx = obj.idx;
          // 既に発火済みならスキップ
          if(currentCard.announcedLines.includes(lineIdx)) continue;

          // ラインの3セルがすべて露出されているか？
          const allRevealed = line.every(i => currentCard.revealed[i]);
          if(!allRevealed) continue;

          // 露出された3セルの画像が全て同じか？
          const a = currentCard.cells[line[0]];
          if(currentCard.cells[line[1]] === a && currentCard.cells[line[2]] === a){
            // このラインが新たに成立 → 記録して演出
            currentCard.announcedLines.push(lineIdx);
            // 個別に当たり演出を出す（該当セルをハイライト＋紙吹雪＋ポップアップ）
            announceLine(line, a);
            // ここでは return しない（同セルで複数ライン成立の可能性があるためループ継続）
          }
        }

        // 全部開いたかは通常どおりチェック（最終的な「はずれ」判定のため）
        const allOpen = currentCard.revealed.every(v=>v===true);
        if(allOpen){
          // 最終判定（全て開けられた時に未発火のラインがあれば announceLine で既に発火しているはず）
          // ただし、揃いが一切無ければ既存の announceResult() で「はずれ」を表示
          const anyWin = LINES.some(line => {
            const a = currentCard.cells[line[0]];
            return currentCard.cells[line[1]]===a && currentCard.cells[line[2]]===a;
          });
          if(!anyWin){
            announceResult(); // はずれ表示
          } else {
            // すでに個別ラインで演出済みならここで改めて全体告知は不要。
            // 必要ならここで追加の総合表示を行ってください（省略可）。
          }
        }
      }
    }
  }catch(err){
    console.warn('checkReveal failed', err);
  }
}


    function hideCanvas(canvas){
      canvas.style.pointerEvents='none'; canvas.style.opacity=0;
    }
    function showCanvas(canvas){ canvas.style.pointerEvents='auto'; canvas.style.opacity=1; }

    // ========== 判定と演出 ==========
    function announceResult(){
      const wins = [];
      LINES.forEach(line=>{
        const a = currentCard.cells[line[0]];
        if(a && currentCard.cells[line[1]]===a && currentCard.cells[line[2]]===a){
          wins.push({line,image:a});
        }
      });
      if(wins.length === 0){
        resultEl.innerHTML = '<strong>はずれ</strong> — 全て開けましたが揃いがありませんでした。';
        return;
      }
      wins.sort((a,b)=> rankOf(a.image) - rankOf(b.image));
      const best = wins[0];
      resultEl.innerHTML = `<strong>当選！</strong> ${best.image} が揃いました。ランク: ${rankOf(best.image)}`;
      wins.forEach(w=> w.line.forEach(i=> cellCanvases[i].cellEl.classList.add('line-highlight')));
      showWinPopup(best.image); launchConfetti();
    }

    function announceLine(line, imageId){
  // ハイライト（既に行っている highlight ロジックと同じ）
  line.forEach(i => {
    if(cellCanvases[i] && cellCanvases[i].cellEl){
      cellCanvases[i].cellEl.classList.add('line-highlight');
    }
  });

  // ポップアップ表示（行ごとの演出）
  const im = IMAGES.find(x=>x.id===imageId);
  winTitle.innerText = '当選おめでとうございます！';
  winSub.innerText = im ? `${im.label} が揃いました` : `${imageId} が揃いました`;
  winPopup.classList.add('show');
  setTimeout(()=> winPopup.classList.remove('show'), 4800);

  // 紙吹雪
  launchConfetti();

  // （任意）result欄に履歴を追記する
  const prev = resultEl.innerHTML;
  const entry = `<div><strong>当選：</strong> ${imageId} が揃いました</div>`;
  resultEl.innerHTML = entry + prev;
}


    function showWinPopup(imageId){
      const im = IMAGES.find(x=>x.id===imageId);
      winTitle.innerText = '当選おめでとうございます！';
      winSub.innerText = im ? `${im.label} が揃いました` : `${imageId} が揃いました`;
      winPopup.classList.add('show');
      setTimeout(()=> winPopup.classList.remove('show'), 5200);
    }

    // 改良版：ゆっくり・時間をかけて落ちる紙吹雪
// 呼び出し例: launchConfetti({count:400, duration:9000});
function launchConfetti(opts){
  opts = opts || {};
  const totalCount = typeof opts.count === 'number' ? opts.count : 1000; // 全体個数（順次生成）
  const DURATION = typeof opts.duration === 'number' ? opts.duration : 3000; // ms 全体持続時間
  const overlay = confettiOverlay;
  const cvs = document.createElement('canvas');
  cvs.width = Math.max(1, overlay.clientWidth);
  cvs.height = Math.max(1, overlay.clientHeight);
  cvs.style.width = '100%';
  cvs.style.height = '100%';
  cvs.style.display = 'block';
  cvs.style.pointerEvents = 'none';
  overlay.appendChild(cvs);
  const ctx = cvs.getContext('2d');

  // パフォーマンス: モバイルなら自動で控えめに
  const ua = navigator.userAgent || '';
  const isMobileLike = /Mobi|Android|iPhone|iPad/i.test(ua);
  const effectiveMax = isMobileLike ? Math.min(totalCount, 500) : totalCount;

  // spawn over time (spawnDuration ms)
  const spawnDuration = Math.max(800, Math.min(DURATION, 6000)); // 最大10sまで分散生成
  const spawnRatePerMs = effectiveMax / spawnDuration;

  const gravity = (typeof opts.gravity === 'number') ? opts.gravity : 0.05; // 重力（小さく）
  const drag = (typeof opts.drag === 'number') ? opts.drag : 0.998; // 空気抵抗（1に近い＝遅い）
  const turbulence = (typeof opts.turbulence === 'number') ? opts.turbulence : 0.4; // 横揺れ係数

  const particles = [];
  let spawned = 0;
  let startTime = null;
  const COLORS = CONFETTI_COLORS && CONFETTI_COLORS.length ? CONFETTI_COLORS : ['#ff4d6d','#ffd166','#8b5cf6','#34d399','#60a5fa'];

  function rand(min, max){ return min + Math.random()*(max-min); }

  function spawnParticles(dtMs, now){
    // 決め打ちで dt に基づき spawn 数を計算
    const shouldSpawn = spawnRatePerMs * dtMs;
    let toSpawn = Math.floor(shouldSpawn + Math.random()); // jitter を入れて自然に
    while(toSpawn > 0 && spawned < effectiveMax){
      toSpawn--;
      spawned++;
      // initial horizontal spread across width, slightly above view
      const x = Math.random() * cvs.width;
      const y = -rand(6, 60); // 少し上にばらつかせる
      // initial velocities: small downward for slow fall, horizontal spread
      const vx = rand(-1.6, 1.6);
      const vy = rand(0.2, 1.8); // 小さめ
      const size = rand(6, 14);
      const color = COLORS[Math.floor(Math.random()*COLORS.length)];
      const rotation = rand(0, 360);
      const vr = rand(-2.5, 2.5);
      const shape = Math.random() < 0.6 ? 'rect' : 'circle';
      // life/time - we won't strictly time each particle; we'll cull when off-screen and past total DURATION + margin
      particles.push({x,y,vx,vy,size,color,rotation,vr,shape,createdAt: now});
    }
  }

  let lastTime = performance.now();

  function step(time){
    if(!startTime) startTime = time;
    const elapsed = time - startTime;
    const dt = Math.min(40, time - lastTime); // ms, clamp to avoid huge jumps
    lastTime = time;

    // spawn according to dt
    if(elapsed <= spawnDuration){
      spawnParticles(dt, time);
    }

    // update
    ctx.clearRect(0,0,cvs.width,cvs.height);
    for(let i = particles.length - 1; i >= 0; i--){
      const p = particles[i];
      // apply gravity, drag, tiny turbulence for flutter
      p.vy += gravity * (dt/16);               // scale by frame time
      p.vx += Math.sin((time + i*13) * 0.002 + i) * (turbulence * 0.03); // subtle horizontal wobble
      p.vx *= Math.pow(drag, dt/16);
      p.vy *= Math.pow(drag, dt/16);

      p.x += p.vx * (dt/16);
      p.y += p.vy * (dt/16);
      p.rotation += p.vr * (dt/16);

      // draw
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(p.rotation * Math.PI/180);
      ctx.fillStyle = p.color;
      if(p.shape === 'rect'){
        ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6);
      } else {
        ctx.beginPath();
        ctx.arc(0, 0, p.size*0.6, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();

      // cull if far below bottom and some time passed since creation
      if(p.y > cvs.height + p.size*8 || elapsed > DURATION + 2000){
        particles.splice(i,1);
      }
    }

    // continue animation while there are particles or still spawning window
    const stillSpawning = (elapsed < spawnDuration) && (spawned < effectiveMax);
    if(stillSpawning || particles.length > 0){
      requestAnimationFrame(step);
    } else {
      // fade out canvas then remove
      const fadeStart = performance.now();
      const fade = ()=>{
        const fElapsed = performance.now() - fadeStart;
        const alpha = Math.max(1 - fElapsed/600, 0);
        cvs.style.opacity = alpha;
        if(alpha > 0) requestAnimationFrame(fade);
        else { try{ overlay.removeChild(cvs); }catch(e){} }
      };
      fade();
    }
  }

  // kick off
  requestAnimationFrame(step);
}

    // ========== BFCache / pageshow 対策 ==========
    function hardInit(){
      renderLegend(); buildGrid(); generateCard();
      window.addEventListener('resize', ()=>{ cellCanvases.forEach(c=> resizeCanvasToElement(c.canvas, c.cellEl)); }, {passive:true});
    }

    window.addEventListener('pageshow', (e)=>{
      const nav = performance.getEntriesByType('navigation')[0];
      const isBF = e.persisted || (nav && nav.type === 'back_forward');
      if(isBF){
        // 再初期化してキャンバスを確実に覆い直す
        resetAll();
        hardInit();
      }
    });

    document.addEventListener('DOMContentLoaded', ()=>{ hardInit(); });

    function resetAll(){
      gridEl.innerHTML=''; legendEl.innerHTML=''; cellCanvases=[]; currentCard=null;
      resultEl.textContent='カードを読み込み中…'; confettiOverlay.querySelectorAll('canvas').forEach(c=>c.remove()); winPopup.classList.remove('show');
    }

    // ========== 初期化呼び出し済み ==========

  </script>
</body>
</html>
